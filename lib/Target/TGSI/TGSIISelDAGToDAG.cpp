//===-- TGSIISelDAGToDAG.cpp - A dag to dag inst selector for TGSI ------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the TGSI target.
//
//===----------------------------------------------------------------------===//

#include "TGSITargetMachine.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

namespace {
   class TGSIDAGToDAGISel : public SelectionDAGISel {
      const TGSISubtarget &Subtarget;
      TGSITargetMachine& TM;
   public:
      explicit TGSIDAGToDAGISel(TGSITargetMachine &tm)
         : SelectionDAGISel(tm),
           Subtarget(tm.getSubtarget<TGSISubtarget>()),
           TM(tm) {
      }

      SDNode *Select(SDNode *N);

      // Complex Pattern Selectors.
      template<int addr_space>
      bool SelectPtr(SDNode *p, SDValue &n, SDValue &v);

      template<bool any_ok>
      bool SelectSrc(SDValue &n, SDValue &v);

      virtual const char *getPassName() const {
         return "TGSI DAG->DAG Pattern Instruction Selection";
      }

      // Include the pieces autogenerated from the target description.
#include "TGSIGenDAGISel.inc"
   };
}

SDNode *TGSIDAGToDAGISel::Select(SDNode *n) {
   DebugLoc dl = n->getDebugLoc();

   switch (n->getOpcode()) {
      case ISD::FrameIndex: {
         int fi = cast<FrameIndexSDNode>(n)->getIndex();
         SDValue tfi = CurDAG->getTargetFrameIndex(fi, MVT::i32);

         return tfi.getNode();
      }
      case ISD::GlobalAddress: {
         const GlobalValue *gv = cast<GlobalAddressSDNode>(n)->getGlobal();
         SDValue tga = CurDAG->getTargetGlobalAddress(gv, dl, MVT::i32);

         return tga.getNode();
      }
   }

   return SelectCode(n);
}

FunctionPass *llvm::createTGSIISelDag(TGSITargetMachine &TM) {
   return new TGSIDAGToDAGISel(TM);
}

template<int addr_space>
bool TGSIDAGToDAGISel::SelectPtr(SDNode *p, SDValue &n, SDValue &r) {
   const Value *v;
   const PointerType *ptr;

   if (ConstantPoolSDNode *c = dyn_cast<ConstantPoolSDNode>(n)) {
      if (addr_space == tgsi::CONSTANT) {
         r = CurDAG->getTargetConstantPool(c->getConstVal(), MVT::i32,
                                           c->getAlignment());
         return true;
      }

   } else {
      if ((v = cast<MemSDNode>(p)->getSrcValue()) &&
          (ptr = dyn_cast<PointerType>(v->getType())) &&
          ptr->getAddressSpace() == addr_space) {
         r = n;
         return true;
      }
   }

   return false;
}

template<bool any_ok>
bool TGSIDAGToDAGISel::SelectSrc(SDValue &v, SDValue &r) {
   SDNode *n = v.getNode();
   DebugLoc dl = n->getDebugLoc();

   if (ConstantSDNode *c = dyn_cast<ConstantSDNode>(n)) {
      r = CurDAG->getTargetConstant(*c->getConstantIntValue(),
                                    n->getValueType(0));
      return true;

   } else if (ConstantFPSDNode *c = dyn_cast<ConstantFPSDNode>(n)) {
      r = CurDAG->getTargetConstantFP(*c->getConstantFPValue(),
                                      n->getValueType(0));
      return true;

   } else if (GlobalAddressSDNode *ga = dyn_cast<GlobalAddressSDNode>(n)) {
      r = CurDAG->getTargetGlobalAddress(ga->getGlobal(), dl, MVT::i32);
      return true;

   } else if (any_ok) {
      r = v;
      return true;
   }

   return false;
}
